/// <reference lib="webworker" />
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  })
);

// Cache arXiv API responses with network-first strategy
registerRoute(
  new RegExp(import.meta.env.VITE_ARXIV_API_URL),
  new NetworkFirst({
    cacheName: 'arxiv-cache',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
        maxEntries: 50,
      }),
    ],
  })
);

// Cache Semantic Scholar API responses with network-first strategy
registerRoute(
  new RegExp(import.meta.env.VITE_SEMANTIC_SCHOLAR_API_URL),
  new NetworkFirst({
    cacheName: 'semantic-scholar-cache',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
        maxEntries: 50,
      }),
    ],
  })
);

// Cache MCP server responses with network-first strategy
registerRoute(
  /^http:\/\/localhost:3000\/mcp/,
  new NetworkFirst({
    cacheName: 'mcp-cache',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
        maxEntries: 100,
      }),
    ],
  })
);

// Cache static assets with cache-first strategy
registerRoute(
  /\.(?:js|css|png|jpg|jpeg|svg|gif)$/,
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
        maxEntries: 100,
      }),
    ],
  })
);

// Handle offline fallback
const FALLBACK_HTML_URL = '/offline.html';

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('offline-fallback').then((cache) => {
      return cache.add(FALLBACK_HTML_URL);
    })
  );
});

self.addEventListener('fetch', (event) => {
  // For navigation requests, try network first then fallback to offline page
  if (event.request.mode === 'navigate') {
    event.respondWith(
      (async () => {
        try {
          return await fetch(event.request);
        } catch {
          const cache = await caches.open('offline-fallback');
          const fallbackResponse = await cache.match(FALLBACK_HTML_URL);
          if (fallbackResponse) {
            return fallbackResponse;
          }
          throw new Error('offline');
        }
      })()
    );
  }
  
  // For API requests that fail, return a JSON response indicating offline status
  if (event.request.url.includes('/api/') || 
      event.request.url.includes('/mcp') ||
      event.request.url.includes(import.meta.env.VITE_ARXIV_API_URL) ||
      event.request.url.includes(import.meta.env.VITE_SEMANTIC_SCHOLAR_API_URL)) {
    event.respondWith(
      (async () => {
        try {
          return await fetch(event.request);
        } catch {
          return new Response(
            JSON.stringify({
              error: 'offline',
              message: 'You are currently offline. Please check your connection and try again.',
            }),
            {
              status: 503,
              headers: { 'Content-Type': 'application/json' },
            }
          );
        }
      })()
    );
  }
});

// Listen for messages from the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
